#include<iostream>
using namespace std;

/*
& 按位与 ： 全1才为1		
| 或		有1则为1 
^ 异或		相同则为1,不同则为0
~ 取反		a = 8 , 1000 , ~a = 0111, ~a = 7
>>（右移）	除以2 
<<（左移）  乘以2 

1.机器码： 
机器数带符号，一般把二进制为的最高位定为其符号位，最高位为0是为非负数，为1是是负数。
例如2表示为00000000 00000000 00000000 00000010，
-3表示为10000000 00000000 00000000 00000011。

2.原码：原码就是符号位加上真值的绝对值
1表示为00000000 00000000 00000000 00000001。
-1表示为10000000 00000000 00000000 00000001。 
 
 
3.反码：非负数和负数的表示方法有所不同
非负数：反码和原码一样
负数：将该负数的原码，符号位保持不变，其余各位进行取反运算 
	   -3 ： 10000000 00000000 00000000 00000011
	~(-3) :  11111111 11111111 11111111 11111100
	
4.补码：非负数和负数的表示方法不同
非负数：补码和原码一样
负数：补码等于反码+1
-1 
原码： 10000000 00000000 00000000 00000001 
反码：11111111 11111111 11111111 11111110 
补码：11111111 11111111 11111111 11111111 


在c/c++中，负数是用补码表示
n = 6 , 
6 原码（无符号类型）：  
   原码：110
  补码： 001
  反码： 010 
  
-n： 010
n & -n = 110 & 010 = 010
因此， n = 6的最右侧的1的位置为2 

n = 10
原码： 1010
反码： 0101
补码： 0110

n & -n = 1010 & 0110 = 0010 
*/

auto lowbit1(int n) -> int
{
	return n & -n;
}	

int lowbit2(int x) {
	return x & -x;
}

/*力扣191. 位1的个数*/
int hammingWeight(uint32_t n) {
    int cnt = 0;
    while (n != 0) {
        int c = n & -n;
        n -= c;
        cnt++;
    }
    return cnt;
}

int main() {
	int a = 2;
	cout << (a>>1) << " "<< (a<<1) << " " << ~a << endl; 
	
	int b = 10;
	cout << "==lowbit==" << endl; 
	cout << lowbit2(b) << endl;
	int c = -b;
	while (c != 0) {
		int a = c%2;
		c = c/2 ;
		cout << a << " ";
	}
	cout << endl;

	cout <<"===" << endl; 
	unsigned int aa = -1;
	cout << aa << endl;  //4294967295
	
	
	int d = 3, e = -3;
	//~n   = -(n+1) 
	cout << d <<" " << (~d) << " " << e << " " << (~e) << endl;  //3 -4 -3 2
	
	return 0;
}

/*
https://zhuanlan.zhihu.com/p/463914865
https://blog.csdn.net/qq_35630119/article/details/123087916
*/ 
